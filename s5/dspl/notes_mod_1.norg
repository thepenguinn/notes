@document.meta
title: Simulation of Signals
description: simulation of signals ( lab, and notes )
authors: Daniel
categories: [
    lab
    notes
]
created: 2024-07-25T19:48:22+0530
updated: 2024-07-26T19:43:15+0530
version: 1.1.1
@end

* Discrete time impulse signal

  Generate and plot a discrete-time impulse

  #tangle discreteTimeImpulse.py
  @code python
  import numpy as np
  import matplotlib.pyplot as plt

  n = np.arange(-5, 6)
  x = np.zeros_like(n)

  x[ n == 0 ] = 1

  plt.stem(n, x)
  plt.xticks(n)

  plt.savefig("plot/discreteTimeImpulse.svg")
  @end

  {plot/discreteTimeImpulse.svg}[Plot]

* Discrete time pulse signal

  Generate a discrete-time pulse signal

  @math
  u(x) =
  \begin{cases}
  1    & \text{if} 0 \leq n \leq 4 \\
  0    & \text{otherwise}
  \end{cases}
  @end

  #tangle discreteTimePulse.py
  @code python
  import numpy as np
  import matplotlib.pyplot as plt

  n = np.arange(-5, 6)
  x = np.zeros_like(n)

  x[(n >= 0) & (n <= 4)] = 1

  plt.stem(n, x)
  plt.xticks(n)

  plt.savefig("plot/discreteTimePulse.svg")
  @end

  {plot/discreteTimePulse.svg}[Plot]

* Discrete time bipolar pulse signal

  Generate and stem the discrete-time bipolar pulse signal

  @math
  u(t) =
  \begin{cases}
  -1  & \text{if} -3 \leq n < 0 \\
  1   & \text{if} 0 \leq n < 3
  \end{cases}
  @end

  #tangle discreteTimeBipolar.py
  @code python
  import numpy as np
  import matplotlib.pyplot as plt

  n = np.arange(-5, 6)
  x = np.zeros_like(n)

  x[(n >= -3) & (n < 0)] = -1
  x[(n >= 0) & (n < 3)] = 1

  plt.stem(n, x)
  plt.xticks(n)

  plt.savefig("plot/discreteTimeBipolar.svg")
  @end

  {plot/discreteTimeBipolar.svg}[Plot]

* Discrete time ramp signal

  Generate and plot a discrete-time ramp signal

  #tangle discreteTimeRamp.py
  @code python
  import numpy as np
  import matplotlib.pyplot as plt

  n = np.arange(0, 11)
  x = n.copy()

  plt.stem(n, x)
  plt.xticks(n)

  plt.savefig("plot/discreteTimeRamp.svg")
  @end

  {plot/discreteTimeRamp.svg}[Plot]

* Discrete time triangluar signal

  Generate a triangluar signal

  #tangle discreteTimeTri.py
  @code python
  import numpy as np
  import matplotlib.pyplot as plt

  a = np.arange(6)
  b = np.arange(4, -1, -1)

  x = np.concatenate([a, b])

  plt.stem(x)
  plt.xticks(np.arange(11))

  plt.savefig("plot/discreteTimeTri.svg")
  @end

  {plot/discreteTimeTri.svg}[Plot]

* Yet another discrete time signal

  Plot the discrete-time signal $x[n] = \{2, -1, 4, 1\}$ using `plt.stem()`.
  Use `np.array` to create `x`

  #tangle yetAnotherDiscreteTimeSignal.py
  @code python
  import numpy as np
  import matplotlib.pyplot as plt

  x = np.array([2, -1, 4, 1])
  plt.stem(x)

  plt.savefig("yetAnotherDiscreteTimeSignal.svg")
  @end

  {yetAnotherDiscreteTimeSignal.svg}[Plot]

* Complex exponential sequence

  Generate the complex exponential sequence:

  @math
  x[n] = e^{( -\dfrac{1}{12} + j\dfrac{\pi}{6}n )}
  @end

  Display both the real and imaginary parts of the signal from $n=0$ to $n=40$
  using `plt.subplot()`

  #tangle complexExpSeq.py
  @code python
  import numpy as np
  import matplotlib.pyplot as plt

  def comp_exp_func (n):
      return np.exp( (-1 / 12) + (1j * np.pi / 6 * n) )

  t = np.arange(0, 41)
  x = comp_exp_func(t)

  plt.figure(figsize = (10, 16))

  plt.subplot(2, 1, 1)
  plt.stem(t, x.real, label = "Real part")
  plt.legend()

  plt.subplot(2, 1, 2)
  plt.stem(t, x.imag, label = "Imaginary part")
  plt.legend()

  plt.savefig("plot/complexExpSeq.svg")
  @end

  {plot/complexExpSeq.svg}[Plot]

* Yet another sequence

  Generate the below signal for $n=0$ to $n=50$:

  @math
  x[n] = (0.95)^{n}\cos(0.1 \pi n)
  @end

  #tangle yetAnotherSeq.py
  @code python
  import numpy as np
  import matplotlib.pyplot as plt

  def yet_another_func(n):
      return (0.95 ** n) * np.cos(0.1 * np.pi * n)

  t = np.arange(0, 51)
  x = yet_another_func(t)

  plt.stem(t, x)

  plt.savefig("plot/yetAnotherSeq.svg")
  @end

  {plot/yetAnotherSeq.svg}[Plot]

* Many more discrete sequences

  Generate $50$ samples of the following discrete time sequences and display
  using stem:

  @math
  x[n] = 20(0.9)^{n}
  @end

  @math
  x[n] = 0.2(1.2)^{n}
  @end

  @math
  x[n] = (-0.8)^{n}
  @end

  @math
  x[n] = -4(0.8)^{n}
  @end

  @math
  x[n] = 2n(0.9)^{n}
  @end

  #tangle manyMoreSeq.py
  @code python
  import numpy as np
  import matplotlib.pyplot as plt

  def func_a (n):
      return 20 * (0.9 ** n)

  def func_b (n):
      return 0.2 * (1.2 ** n)

  def func_c (n):
      return (-0.8 ** n)

  def func_d (n):
      return -4 * (0.8 ** n)

  def func_e (n):
      return 2 * n * (0.9 ** n)

  t = np.arange(0, 51)
  a = func_a(t)
  b = func_b(t)
  c = func_c(t)
  d = func_d(t)
  e = func_e(t)

  plt.figure(figsize = (10, 20))

  plt.subplot(5, 1, 1)
  plt.stem(t, a)

  plt.subplot(5, 1, 2)
  plt.stem(t, b)

  plt.subplot(5, 1, 3)
  plt.stem(t, c)

  plt.subplot(5, 1, 4)
  plt.stem(t, d)

  plt.subplot(5, 1, 5)
  plt.stem(t, e)

  plt.savefig("plot/manyMoreSeq.svg")
  @end

  {plot/manyMoreSeq.svg}[]

* Discrete time sinosoids

  Generate the discrete-time sinosoids and compare the plots generated for the
  three cases and comment on your result:

  @math
  x_{1}[n] = \sin(0.2 \pi n)
  @end

  @math
  x_{2}[n] = \sin(1.8 \pi n)
  @end

  @math
  x_{3}[n] = \sin(2.2 \pi n)
  @end

  #tangle discreteTimeSinusoids.py
  @code python
  import numpy as np
  import matplotlib.pyplot as plt

  def func_a (n):
      return np.sin(0.2 * np.pi * n)

  def func_b (n):
      return np.sin(1.8 * np.pi * n)

  def func_c (n):
      return np.sin(2.2 * np.pi * n)

  t = np.arange(0, 51)
  a = func_a(t)
  b = func_b(t)
  c = func_c(t)

  plt.figure(figsize = (10, 20))

  plt.subplot(3, 1, 1)
  plt.stem(t, a)

  plt.subplot(3, 1, 2)
  plt.stem(t, b)

  plt.subplot(3, 1, 3)
  plt.stem(t, c)

  plt.savefig("plot/discreteTimeSinusoids.svg")
  @end

  {plot/discreteTimeSinusoids.svg}[Plot]

* Continuous time signals
* Rectified sine wave
* Random signals
* More random signals
* Sine wave corrupted with noise
