@document.meta
title: Simulation of Signals
description: simulation of signals ( lab, and notes )
authors: Daniel
categories: [
    lab
    notes
]
created: 2024-07-25T19:48:22+0530
updated: 2024-08-02T20:10:18+0530
version: 1.1.1
@end

* Discrete Time Impulse Signal

  Generate and plot a discrete-time impulse signal.

** Python Implementation

   #tangle discreteTimeImpulse.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   n = np.arange(-5, 6)
   x = np.zeros_like(n)

   x[ n == 0 ] = 1

   plt.stem(n, x)
   plt.xticks(n)

   plt.savefig("../plot/discreteTimeImpulse.pdf")
   @end

** Plots

   {plot/discreteTimeImpulse.pdf}[Discrete Time Impulse Signal]

* Discrete Time Pulse Signal

  Generate a discrete-time pulse signal:

  @math
  u(x) =
  \begin{cases}
  \; 1    & \text{; if}\; 0 \leq n \leq 4 \\
  \; 0    & \text{; otherwise}
  \end{cases}
  @end

** Python Implementation

   #tangle discreteTimePulse.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   n = np.arange(-5, 6)
   x = np.zeros_like(n)

   x[(n >= 0) & (n <= 4)] = 1

   plt.stem(n, x)
   plt.xticks(n)

   plt.savefig("../plot/discreteTimePulse.pdf")
   @end

** Plots

   {plot/discreteTimePulse.pdf}[Discrete Time Pulse Signal]

* Discrete Time Bipolar Pulse Signal

  Generate and stem the discrete-time bipolar pulse signal:

  @math
  u(t) =
  \begin{cases}
  -1        & \text{; if} -3 \leq n < 0 \\
  \hfill 1  & \text{; if} \hfill 0 \leq n < 3 \\
  \hfill 0  & \text{; otherwise}
  \end{cases}
  @end

** Python Implementation

   #tangle discreteTimeBipolar.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   n = np.arange(-5, 6)
   x = np.zeros_like(n)

   x[(n >= -3) & (n < 0)] = -1
   x[(n >= 0) & (n < 3)] = 1

   plt.stem(n, x)
   plt.xticks(n)

   plt.savefig("../plot/discreteTimeBipolar.pdf")
   @end

** Plots

   {plot/discreteTimeBipolar.pdf}[Discrete Time Bipolar Pulse Signal]

* Discrete Time Ramp Signal

  Generate and plot a discrete-time ramp signal.

** Python Implementation

   #tangle discreteTimeRamp.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   n = np.arange(0, 11)
   x = n.copy()

   plt.stem(n, x)
   plt.xticks(n)

   plt.savefig("../plot/discreteTimeRamp.pdf")
   @end

** Plots

   {plot/discreteTimeRamp.pdf}[Discrete Time Ramp Signal]

* Discrete Time Triangluar Signal

  Generate a triangluar signal.

** Python Implementation

   #tangle discreteTimeTri.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   a = np.arange(6)
   b = np.arange(4, -1, -1)

   x = np.concatenate([a, b])

   plt.stem(x)
   plt.xticks(np.arange(11))

   plt.savefig("../plot/discreteTimeTri.pdf")
   @end

** Plots

   {plot/discreteTimeTri.pdf}[Discrete Time Triangluar Signal]

* Yet Another Discrete Time Signal

  Plot the discrete-time signal $x[n] = \{2, -1, 4, 1\}$ using `plt.stem()`.
  Use `np.array` to create `x`.

** Python Implementation

   #tangle yetAnotherDiscreteTimeSignal.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   x = np.array([2, -1, 4, 1])
   plt.stem(x)

   plt.savefig("../plot/yetAnotherDiscreteTimeSignal.pdf")
   @end

** Plots

   {plot/yetAnotherDiscreteTimeSignal.pdf}[Yet Another Discrete Time Signal]

* Complex Exponential Sequence

  Generate the complex exponential sequence:

  @math
  x[n] = e^{\bigg( -\dfrac{1}{12} + \dfrac{j \pi n}{6} \bigg)}
  @end

  Display both the real and imaginary parts of the signal from $n=0$ to $n=40$
  using `plt.subplot()`.

** Python Implementation

   #tangle complexExpSeq.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   def comp_exp_func (n):
       return np.exp( (-1 / 12) + (1j * np.pi / 6 * n) )

   t = np.arange(0, 41)
   x = comp_exp_func(t)

   plt.figure(figsize = (10, 16))

   plt.subplot(2, 1, 1)
   plt.stem(t, x.real, label = "Real part")
   plt.legend()

   plt.subplot(2, 1, 2)
   plt.stem(t, x.imag, label = "Imaginary part")
   plt.legend()

   plt.savefig("../plot/complexExpSeq.pdf")
   @end

** Plots

   {plot/complexExpSeq.pdf}[Complex Exponential Sequence]

* Yet Another Sequence

  Generate the below signal for $n=0$ to $n=50$:

  @math
  x[n] = (0.95)^{n}\cos(0.1 \pi n)
  @end

** Python Implementation

   #tangle yetAnotherSeq.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   def yet_another_func(n):
       return (0.95 ** n) * np.cos(0.1 * np.pi * n)

   t = np.arange(0, 51)
   x = yet_another_func(t)

   plt.stem(t, x)

   plt.savefig("../plot/yetAnotherSeq.pdf")
   @end

** Plots

   {plot/yetAnotherSeq.pdf}[Yet Another Sequence]

* Many more Discrete Sequences

  Generate $50$ samples of the following discrete time sequences and display
  using stem:

  @math
  x[n] = 20(0.9)^{n}
  @end

  @math
  x[n] = 0.2(1.2)^{n}
  @end

  @math
  x[n] = (-0.8)^{n}
  @end

  @math
  x[n] = -4(0.8)^{n}
  @end

  @math
  x[n] = 2n(0.9)^{n}
  @end

** Python Implementation

   #tangle manyMoreSeq.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   def func_a (n):
       return 20 * (0.9 ** n)

   def func_b (n):
       return 0.2 * (1.2 ** n)

   def func_c (n):
       return (-0.8 ** n)

   def func_d (n):
       return -4 * (0.8 ** n)

   def func_e (n):
       return 2 * n * (0.9 ** n)

   t = np.arange(0, 51)
   a = func_a(t)
   b = func_b(t)
   c = func_c(t)
   d = func_d(t)
   e = func_e(t)

   plt.figure(figsize = (10, 20))

   plt.subplot(5, 1, 1)
   plt.stem(t, a)

   plt.subplot(5, 1, 2)
   plt.stem(t, b)

   plt.subplot(5, 1, 3)
   plt.stem(t, c)

   plt.subplot(5, 1, 4)
   plt.stem(t, d)

   plt.subplot(5, 1, 5)
   plt.stem(t, e)

   plt.savefig("../plot/manyMoreSeq.pdf")
   @end

** Plots

   {plot/manyMoreSeq.pdf}[Many more Discrete Sequences]

* Discrete Time Sinosoids

  Generate the discrete-time sinosoids and compare the plots generated for the
  three cases and comment on your result:

  @math
  x_{1}[n] = \sin(0.2 \pi n)
  @end

  @math
  x_{2}[n] = \sin(1.8 \pi n)
  @end

  @math
  x_{3}[n] = \sin(2.2 \pi n)
  @end

** Python Implementation

   #tangle discreteTimeSinusoids.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   def func_a (n):
       return np.sin(0.2 * np.pi * n)

   def func_b (n):
       return np.sin(1.8 * np.pi * n)

   def func_c (n):
       return np.sin(2.2 * np.pi * n)

   t = np.arange(0, 51)
   a = func_a(t)
   b = func_b(t)
   c = func_c(t)

   plt.figure(figsize = (10, 20))

   plt.subplot(3, 1, 1)
   plt.stem(t, a)

   plt.subplot(3, 1, 2)
   plt.stem(t, b)

   plt.subplot(3, 1, 3)
   plt.stem(t, c)

   plt.savefig("../plot/discreteTimeSinusoids.pdf")
   @end

** Plots

   {plot/discreteTimeSinusoids.pdf}[Discrete Time Sinosoids]

* Continuous Time Signals

  Even though all signals that we generate on a digital computer are
  necessarily discrete, we can simulate a continuous time signal by sampling at
  a high rate and graphing it as a continuous curve using `plt.plot()`.

** Python Implementation

   #tangle continousTimeSignals.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   t = np.arange(0, 1, 0.02)
   x = np.sin(2 * np.pi * 1 * t)
   y = np.sin(2 * np.pi * 2 * t)

   plt.plot(t, x, label = "1 Hz")
   plt.plot(t, y, label = "2 Hz")
   plt.legend()

   plt.savefig("../plot/continousTimeSignals.pdf")
   @end

** Plots

   {plot/continousTimeSignals.pdf}[Continuous Time Signals]

* Rectified Sine Wave

  Generate and plot a sine wave and the full wave rectified version:

  @math
  x(t) =
  \begin{cases}
  \; \sin(t) & \text{; if} \; -2\pi \leq t \leq 2\pi \\
  \hfill 0   & \text{; otherwise}
  \end{cases}
  @end

** Python Implementation

   #tangle rectifiedSine.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   t = np.arange(-2 * np.pi, 2 * np.pi, 0.02)
   s = np.sin(t)
   rs = np.abs(s)

   plt.plot(t, s, label = "Non Rectified")
   plt.plot(t, rs, label = "Rectified")
   plt.legend()

   plt.savefig("../plot/rectifiedSine.pdf")
   @end

** Plots

   {plot/rectifiedSine.pdf}[Rectified Sine Wave]

* Random Signals

  Random signals: A random signal of length N with samples uniformly
  distributed in the interval $[0,1)$ can be generated by usning the command
  `x = np.random.random_sample(N)`. Generate and display a random signal of length
  $100$ whose elements are distributed in the interval $[-2,2)$.

** Python Implementation

   #tangle randomSignals.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   x = np.random.random_sample(100)
   x = (x * 4) - 2

   plt.stem(x)

   plt.savefig("../plot/randomSignals.pdf")
   @end

** Plots

   {plot/randomSignals.pdf}[Random Signals]

* More Random Signals

  Likewise, a random signal $x[n]$ of length $N$ with samples normally
  distributed with zero mean and unity standard deviation can be generated
  by using the following command `x = np.random.normal(0.0, 1.0, N)`.

  Generate and display a Gaussian random signal of length $75$  whose elements
  are normally distributed with zero mean and a variance of $3$. And verify
  the results with `np.mean()` and `np.var()`.

** Python Implementation

   #tangle moreRandomSignals.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   x = np.random.normal(0.0, np.sqrt(3), 75)

   plt.stem(x)

   print("Mean of the random signal: " + str(np.mean(x)))
   print("Variance of the random signal: " + str(np.var(x)))

   plt.savefig("../plot/moreRandomSignals.pdf")
   @end


** Output

   @code
   Mean of the random signal: -0.004406140399603042
   Variance of the random signal: 2.550808884443705
   @end

** Plots

   {plot/moreRandomSignals.pdf}[More Random Signals]

* Sine Wave Corrupted with Noise

  Generate and plot a sinewave corrupted with zero mean Gaussian noise. And
  plot the noisy signal for various values of std dev for the noise.

** Python Implementation

   #tangle corruptedSineWave.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   def corrupt_signal(sig, sdev):
       noise = np.random.normal(0, sdev, sig.size)
       return sig + noise

   sdevs = [0.2, 0.7, 1.3]

   t = np.arange(0, 2, 0.01)
   signal = np.sin(2 * np.pi * t)

   plt.figure(figsize = (10, 20))

   plt.subplot(len(sdevs) + 1, 1, 1)
   plt.plot(t, signal, label = "Original signal")
   plt.legend()

   for i in range(len(sdevs)):
       noisy_signal = corrupt_signal(signal, sdevs[i])
       plt.subplot(len(sdevs) + 1, 1, i + 2)
       plt.plot(
           t, noisy_signal,
           label = "Corrupted signal with gaussian noise of " + str(sdevs[i]) + " sdev"
       )
       plt.legend()

   plt.savefig("../plot/corruptedSineWave.pdf")
   @end

** Plots

   {plot/corruptedSineWave.pdf}[Sine Wave Corrupted with Noise]
