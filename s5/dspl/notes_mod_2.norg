@document.meta
title: Discrete Fourier Transform
description: discrete fourier transform ( lab, and notes )
authors: Daniel
categories: [
    lab
    notes
]
created: 2024-08-06T04:43:03+0530
updated: 2024-08-15T05:28:05+0530
version: 1.1.1
@end

* Introduction

  The DFT $X[k]$ of a finite length sequence $x[n]$ defined for $n = 0 \\ldots N-1$
  can be obtained by sampling its DTFT,

  @math
  X(e^{j\omega})
  @end

  on the $\\omega$ axis between $0 \\leq \\omega < 2 \\pi$ at

  @math
  \omega_{k} = \dfrac{2 \pi k}{N}
  \; \bigg|_{ k = 0 \ldots N - 1 }
  @end

  ie,

  @math
  \mbox{ DFT }\{x[n]\} \quad = \quad
  X[k] \quad = \quad
  X(e^{ j \omega })
  \; \bigg|_{ \omega = \dfrac{ 2 \pi k }{ N }} \quad = \quad
  \sum_{ n = 0 }^{ N - 1 } x[n] \; e^{\bigg( - \dfrac{ j 2 \pi k n }{ N } \bigg)}
  @end

  Using the commonly used notation,

  @math
  \mathbf{X[k]} =
  \sum_{ n = 0 }^{ N - 1 } \mathbf{x[n]} \; \mathbf{W_{N}}^{kn}
  \; \bigg|_{ k = 0 \ldots N - 1 }
  @end

  Where:

  - $\\mathbf{x[n]}$: is the sequence
  - $\\mathbf{X[K]}$: is the DFT
  - $\\mathbf{W_{N}}$: is

  @math
  W_{N} = e^{\bigg(\dfrac{ - j 2 \pi }{N}\bigg)}
  @end

  It is possible to view the DFT equation as a linear transformation on the sequence $x[n]$
  as,

  @math
  \mathbf{ X = D_{N} \cdot x }
  @end

  Where:

  - $\\mathbf{X}$: is the vector composed of $N$ DFT samples,

  @math
  X = \big[
  X[0], X[1], \ldots X[N - 1]
  \big]^{T}
  @end

  - $\\mathbf{x}$: is the vector of $N$ input samples,

  @math
  x = \big[
  x[0], x[1], \ldots x[N - 1]
  \big]^{T}
  @end

  - $\\mathbf{D_{N}}$: is the $N \\times N$ DFT matrix given by,

  @math
  D_{N} =
  \begin{pNiceMatrix}[columns-width=auto]
  1      &               1 &               1 & \ldots &                      1 \\
  1      &       W_{N}^{1} &       W_{N}^{2} & \ldots &        W_{N}^{(N - 1)} \\
  1      &       W_{N}^{2} &       W_{N}^{4} & \ldots &      W_{N}^{2 (N - 1)} \\
  \vdots &          \vdots &          \vdots &  \cdot &                 \vdots \\
  1      & W_{N}^{(N - 1)} & W_{N}^{(N - 1)} & \ldots & W_{N}^{(N - 1)(N - 1)} \\
  \end{pNiceMatrix}
  @end

  To understand how this is correct, consider a general linear transformation of the form
  $y = Ax$. We can write this matrix equation in scalar form as $y_{i} = \\sum_{j} a_{ij} x_{j}$.
  If we rearrange the DFT equation as,

  @math
  X[k] =
  \sum_{n = 0}^{N - 1}
  W_{N}^{kn} \; x[n]
  @end

  we see that the two are similar in form. Just as the $(i, j)\\mbox{th}$ element of $A$ is $a_{ij}$,
  the $(k, n)\\mbox{th}$ element (counting from 0) of $D_{N}$ is $W_{N}^{kn}$. This is exactly how the
  matrix $D_{N}$ is arranged.

* Computing DFT Matrix Using Loops

  We can generate the DFT matrix in a straightforward manner using two for loops:

  %dft_python/dftMatrixTwoLoopMethod.py%
  #tangle dftMatrixTwoLoopMethod.py
  @code python
  # pass
  @end

  One for loop can be eliminated if we define `k` as an array:

  %dft_python/dftMatrixOneLoopMethod.py%
  #tangle dftMatrixOneLoopMethod.py
  @code python
  # pass
  @end

* Computing DFT Matrix Using Matrix Method

  Compute the DFT of the sequence $x[n] = {1, 2, 3, 4}$ using the matrix method.
  And verify the answer using the `scipy.fft.fft()` function which implements
  the fast FFT algorithm for DFT computation:

  %dft_python/dftMatrixMatrixMethod.py%
  #tangle dftMatrixMatrixMethod.py
  @code python
  # pass
  @end

* Computing DFt Matrix Using Direct Evaluation of DFT Equation

  Compute the DFT of the sequence in above section by direct evaluation of the
  DFT equation.

  %dft_python/dftMatrixEquationMethod.py%
  #tangle dftMatrixEquationMethod.py
  @code python
  # pass
  @end

* Comparing The Computation Time for Each Method

  Compare the computation time for the three methods using the `%%timeit` cell
  magic in Jupyter notebook.

  %dft_python/dftMatrixTiming.py%
  #tangle dftMatrixTiming.py
  @code python
  # pass
  @end

* Computing a 64 Point DFT

  Compute a $64$ point DFT matrix and plot it's real and imaginary parts using
  `plt.imshow(D.real)` and `plt.imshow(D.imag)`.

  %dft_python/dftMatrixSixtyFourPoint.py%
  #tangle dftMatrixSixtyFourPoint.py
  @code python
  # pass
  @end

* Circular Convolution Using Concentric Circles

  The circular convolution of two $N$ point sequences $g[n]$ and h[n] is another
  $N$ point sequence $y[n]$ defined as,

  @math
  y[n]
  \sum_{k = 0}^{N - 1} g[k] h\big[(n - k)_{N}\big]
  @end

  To perform circular convolution graphically, $N$ samples $g[n]$ are equally spaced
  around the outer circle in the clockwise direction, and $N$ samples of $h[n]$ are
  displayed on the inner circle in the counterclockwise direction starting at the
  same point. Corresponding samples on the two circles are multiplied, and the products
  are summed to form an output. The successive value of the circular convolution is
  obtained by rotating the inner circle of the one sample in the clockwise direction,
  and repeating the operation of computing the sum of corresponding products. This
  process is repeated until the first sample of inner circle lines up with the first
  sample of the exterior circle again.

  %dft_python/circConvWithoutPadding.py%
  #tangle circConvWithoutPadding.py
  @code python
  # pass
  @end

* Above with Unequally Sized Functions

  The above implementation raises an exception when the sequences are not of the same
  length. Modify the function such that if the two sequences are not of the same length,
  the shorter sequence is padded with zeros and circular convolution is computed.

  %dft_python/circConvWithPadding.py%
  #tangle circConvWithPadding.py
  @code python
  # pass
  @end

* More Circular Convolution

  Using your function, compute the circular convolution of two sequences
  $g[n] = \\{1, 2, 3, 4, 5\\}$ and $h[n] = \\{2, 2, 0, 1, 1\\}$ and

  %dft_python/moreCircConvComp.py%
  #tangle moreCircConvComp.py
  @code python
  # pass
  @end

* Verifying Circular Convolution with Property

  If $y[n]$ is the $N$ point circular convolution of the sequences $g[n]$ and
  $h[n]$ defined as $y[n] = g[n] \\otimes h[n]$, then $Y[k] = G[k] \\cdot H[k]$,
  where $Y[k]$, $G[k]$, $H[k]$ are the $N$ point DFTs of $y[n]$, $g[n]$ and $h[n]$.
  We can use this property to compute circular convolution as:

  @math
  y[n] = \mbox{IDFT}\big\{ G[k] \cdot H[k] \big\}
  @end

  Use this property to verify your circular convolution result in the previous part.
  Use `fft.fft()` and `fft.ifft()` functions in the `scipy` module to compute the DFTs
  and IDFT.

  %dft_python/circConvWithProperty.py%
  #tangle circConvWithProperty.py
  @code python
  # pass
  @end

* Circular Convolution Using Matrix Method

  The $N$ point circular convolution operation can be written in matrix form as

  @math
  \begin{pNiceMatrix}[columns-width=auto]
  y[0]     \\
  y[1]     \\
  y[2]     \\
  \vdots   \\
  y[N - 1] \\
  \end{pNiceMatrix}
  =
  \begin{pNiceMatrix}[columns-width = 1.7cm]
  h[0]     & h[N - 1] &  [N - 2] & \ldots &   h[1] \\
  h[0]     &     h[0] &  [N - 1] & \ldots &   h[2] \\
  h[0]     &     h[1] &     h[0] & \ldots &   h[3] \\
  \vdots   &  \vdots  &   \vdots &  \cdot & \vdots \\
  h[N - 1] & h[N - 2] & h[N - 3] & \ldots &   h[0] \\
  \end{pNiceMatrix}
  \begin{pNiceMatrix}
  g[0]     \\
  g[1]     \\
  g[2]     \\
  \vdots   \\
  g[N - 1] \\
  \end{pNiceMatrix}
  @end

  %dft_python/circConvWithMatrix.py%
  #tangle circConvWithMatrix.py
  @code python
  # pass
  @end

* Parseval'S Relations

  If $G[k]$ denotes the $N$ point DFT of the length $N$ sequence $g[n]$, then:

  @math
  \sum_{n = 0}^{N - 1} \lvert g[n] \rvert^{2} =
  \dfrac{1}{N} \sum_{k = 0}^{N - 1} \lvert G[k] \rvert^{2}
  @end

  The code below verifies the relation for a sequence $g[n]$:

  %dft_python/parsevalsRelation.py%
  #tangle parsevalsRelation.py
  @code python
  # pass
  @end

* Verifying Parseval'S Relation For a Sequence.

  Generate a randoom complex sequence of $500$ values. Verify Parseval's relation for
  the sequence.

  %dft_python/verifyParsevalsRelation.py%
  #tangle verifyParsevalsRelation.py
  @code python
  # pass
  @end
