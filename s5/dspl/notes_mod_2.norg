@document.meta
title: Discrete Fourier Transform
description: discrete fourier transform ( lab, and notes )
authors: Daniel
categories: [
    lab
    notes
]
created: 2024-08-06T04:43:03+0530
updated: 2024-08-15T18:08:53+0530
version: 1.1.1
@end

* Introduction

  The DFT $X[k]$ of a finite length sequence $x[n]$ defined for $n = 0 \\ldots N-1$
  can be obtained by sampling its DTFT,

  @math
  X(e^{j\omega})
  @end

  on the $\\omega$ axis between $0 \\leq \\omega < 2 \\pi$ at

  @math
  \omega_{k} = \dfrac{2 \pi k}{N}
  \; \bigg|_{ k = 0 \ldots N - 1 }
  @end

  ie,

  @math
  \mbox{ DFT }\{x[n]\} \quad = \quad
  X[k] \quad = \quad
  X(e^{ j \omega })
  \; \bigg|_{ \omega = \dfrac{ 2 \pi k }{ N }} \quad = \quad
  \sum_{ n = 0 }^{ N - 1 } x[n] \; e^{\bigg( - \dfrac{ j 2 \pi k n }{ N } \bigg)}
  @end

  Using the commonly used notation,

  @math
  \mathbf{X[k]} =
  \sum_{ n = 0 }^{ N - 1 } \mathbf{x[n]} \; \mathbf{W_{N}}^{kn}
  \; \bigg|_{ k = 0 \ldots N - 1 }
  @end

  Where:

  - $\\mathbf{x[n]}$: is the sequence
  - $\\mathbf{X[K]}$: is the DFT
  - $\\mathbf{W_{N}}$: is

  @math
  W_{N} = e^{\bigg(\dfrac{ - j 2 \pi }{N}\bigg)}
  @end

** DFT Equation as a Linear Transform

   It is possible to view the DFT equation as a linear transformation on the sequence $x[n]$
   as,

   @math
   \mathbf{ X = D_{N} \cdot x }
   @end

   Where:

   - $\\mathbf{X}$: is the vector composed of $N$ DFT samples,

   @math
   X = \big[
   X[0], X[1], \ldots X[N - 1]
   \big]^{T}
   @end

   - $\\mathbf{x}$: is the vector of $N$ input samples,

   @math
   x = \big[
   x[0], x[1], \ldots x[N - 1]
   \big]^{T}
   @end

   - $\\mathbf{D_{N}}$: is the $N \\times N$ DFT matrix given by,

   @math
   D_{N} =
   \begin{pNiceMatrix}[columns-width=auto]
   1      &               1 &               1 & \ldots &                      1 \\
   1      &       W_{N}^{1} &       W_{N}^{2} & \ldots &        W_{N}^{(N - 1)} \\
   1      &       W_{N}^{2} &       W_{N}^{4} & \ldots &      W_{N}^{2 (N - 1)} \\
   \vdots &          \vdots &          \vdots &  \cdot &                 \vdots \\
   1      & W_{N}^{(N - 1)} & W_{N}^{(N - 1)} & \ldots & W_{N}^{(N - 1)(N - 1)} \\
   \end{pNiceMatrix}
   @end

   To understand how this is correct, consider a general linear transformation of the form
   $y = Ax$. We can write this matrix equation in scalar form as $y_{i} = \\sum_{j} a_{ij} x_{j}$.
   If we rearrange the DFT equation as,

   @math
   X[k] =
   \sum_{n = 0}^{N - 1}
   W_{N}^{kn} \; x[n]
   @end

   we see that the two are similar in form. Just as the $(i, j)\\mbox{th}$ element of $A$ is $a_{ij}$,
   the $(k, n)\\mbox{th}$ element (counting from 0) of $D_{N}$ is $W_{N}^{kn}$. This is exactly how the
   matrix $D_{N}$ is arranged.

* Computing DFT Matrix Using Loops

  We can generate the DFT matrix in a straightforward manner using two for loops:

** Python Implementation using Two Loops

   %dft_python/dftMatrixTwoLoopMethod.py%
   #tangle dftMatrixTwoLoopMethod.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   N = 4
   D = np.empty((N, N), dtype = np.cdouble)

   W = np.exp(-1j * 2 * np.pi / N)

   for k in np.arange(N):
       for n in np.arange(N):
           D[k, n] = W ** (k * n)

   np.round(D)
   print(D)
   @end

*** Output

    @code
    [[ 1.0000000e+00+0.0000000e+00j  1.0000000e+00+0.0000000e+00j
       1.0000000e+00+0.0000000e+00j  1.0000000e+00+0.0000000e+00j]
     [ 1.0000000e+00+0.0000000e+00j  6.1232340e-17-1.0000000e+00j
      -1.0000000e+00-1.2246468e-16j -1.8369702e-16+1.0000000e+00j]
     [ 1.0000000e+00+0.0000000e+00j -1.0000000e+00-1.2246468e-16j
       1.0000000e+00+2.4492936e-16j -1.0000000e+00-3.6739404e-16j]
     [ 1.0000000e+00+0.0000000e+00j -1.8369702e-16+1.0000000e+00j
      -1.0000000e+00-3.6739404e-16j  5.5109106e-16-1.0000000e+00j]]
    @end

    ---

** Python Implementation Using a Single Loop

   One for loop can be eliminated if we define `k` as an array:

   %dft_python/dftMatrixOneLoopMethod.py%
   #tangle dftMatrixOneLoopMethod.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   N = 4
   D = np.empty((N, N), dtype = np.cdouble)

   W = np.exp(-1j * 2 * np.pi / N)
   k = np.arange(N)

   for n in np.arange(N):
       D[:, n] = W ** (k * n)

   np.round(D)
   print(D)
   @end

*** Output

    @code
    [[ 1.0000000e+00+0.0000000e+00j  1.0000000e+00+0.0000000e+00j
       1.0000000e+00+0.0000000e+00j  1.0000000e+00+0.0000000e+00j]
     [ 1.0000000e+00+0.0000000e+00j  6.1232340e-17-1.0000000e+00j
      -1.0000000e+00-1.2246468e-16j -1.8369702e-16+1.0000000e+00j]
     [ 1.0000000e+00+0.0000000e+00j -1.0000000e+00-1.2246468e-16j
       1.0000000e+00+2.4492936e-16j -1.0000000e+00-3.6739404e-16j]
     [ 1.0000000e+00+0.0000000e+00j -1.8369702e-16+1.0000000e+00j
      -1.0000000e+00-3.6739404e-16j  5.5109106e-16-1.0000000e+00j]]
    @end

    ---

* Computing DFT Matrix Using Matrix Method

  Compute the DFT of the sequence $x[n] = {1, 2, 3, 4}$ using the matrix method.
  And verify the answer using the `scipy.fft.fft()` function which implements
  the fast FFT algorithm for DFT computation:

** Python Implementation

    %dft_python/dftMatrixMatrixMethod.py%
    #tangle dftMatrixMatrixMethod.py
    @code python
    import numpy as np
    import matplotlib.pyplot as plt
    from scipy import fft

    N = 4
    D = np.empty((N, N), dtype = np.cdouble)

    W = np.exp(-1j * 2 * np.pi / N)
    k = np.arange(N)

    for n in np.arange(N):
        D[:, n] = W ** (k * n)

    np.round(D)

    x = np.array([[1, 2, 3, 4]]).T
    X = D @ x

    np.round(X)

    print("DFT using matrix method:")
    print(X)
    print("")

    # verifying using scipy.fft.fft()

    SX = fft.fft(x, axis = 0)

    print("DFT using scipy:")
    print(SX)
    @end

*** Output

    @code
    DFT using matrix method:
    [[10.+0.00000000e+00j]
     [-2.+2.00000000e+00j]
     [-2.-9.79717439e-16j]
     [-2.-2.00000000e+00j]]

    DFT using scipy:
    [[10.-0.j]
     [-2.+2.j]
     [-2.-0.j]
     [-2.-2.j]]
    @end

    ---

* Computing DFt Matrix Using Direct Evaluation of DFT Equation

  Compute the DFT of the sequence in above section by direct evaluation of the
  DFT equation.

  %dft_python/dftMatrixEquationMethod.py%
  #tangle dftMatrixEquationMethod.py
  @code python
  import matplotlib.pyplot as plt
  import numpy as np

  global np

  N = 4

  def dft_func (k, n):
      global N
      return np.exp(-1j * 2 * np.pi / N * k * n)

  D = np.empty((N, N), dtype = np.cdouble)

  for k in range(N):
      for n in range(N):
          D[k, n] = dft_func(k, n)

  np.round(D)

  print(D)
  @end

** Output

   @code
   [[ 1.0000000e+00+0.0000000e+00j  1.0000000e+00+0.0000000e+00j
      1.0000000e+00+0.0000000e+00j  1.0000000e+00+0.0000000e+00j]
    [ 1.0000000e+00+0.0000000e+00j  6.1232340e-17-1.0000000e+00j
     -1.0000000e+00-1.2246468e-16j -1.8369702e-16+1.0000000e+00j]
    [ 1.0000000e+00+0.0000000e+00j -1.0000000e+00-1.2246468e-16j
      1.0000000e+00+2.4492936e-16j -1.0000000e+00-3.6739404e-16j]
    [ 1.0000000e+00+0.0000000e+00j -1.8369702e-16+1.0000000e+00j
     -1.0000000e+00-3.6739404e-16j  5.5109106e-16-1.0000000e+00j]]
   @end

   ---

* Comparing The Computation Time for Each Method

  %TODO: either create a funcion to execute each in a loop, or just copy the%
  %output from Jupyter%

  Compare the computation time for the three methods using the `%%timeit` cell
  magic in Jupyter notebook.

  %dft_python/dftMatrixTiming.py%
  #tangle dftMatrixTiming.py
  @code python
  # pass
  @end

* Computing a 64 Point DFT

  Compute a $64$ point DFT matrix and plot it's real and imaginary parts using
  `plt.imshow(D.real)` and `plt.imshow(D.imag)`.

** Python Implementation

   %dft_python/dftMatrixSixtyFourPoint.py%
   #tangle dftMatrixSixtyFourPoint.py
   @code python
   import numpy as np
   import matplotlib.pyplot as plt

   N = 64
   D = np.empty((N, N), dtype = np.cdouble)

   W = np.exp(-1j * 2 * np.pi / N)
   k = np.arange(N)

   for n in np.arange(N):
       D[:, n] = W ** (k * n)

   np.round(D)
   real = plt.imshow(D.real)
   real.set_cmap("gist_earth")
   plt.savefig("../dft_plots/dftMatrixSixtyFourPointReal.pdf", bbox_inches = "tight")

   plt.clf()
   imag = plt.imshow(D.imag)
   imag.set_cmap("gist_earth")
   plt.savefig("../dft_plots/dftMatrixSixtyFourPointImaginary.pdf", bbox_inches = "tight")
   # plt.imsave("../dft_plots/dftMatrixSixtyFourPointReal.pdf", D.real, dpi = 20)
   # plt.imsave("../dft_plots/dftMatrixSixtyFourPointImaginary.pdf", D.imag, dpi = 20)
   @end

*** Plots

    {dft_plots/dftMatrixSixtyFourPointReal.pdf}[Real part of 64 point dft matrix]

    {dft_plots/dftMatrixSixtyFourPointImaginary.pdf}[Imaginary part of 64 point dft matrix]

* Circular Convolution Using Concentric Circles

  The circular convolution of two $N$ point sequences $g[n]$ and h[n] is another
  $N$ point sequence $y[n]$ defined as,

  @math
  y[n]
  \sum_{k = 0}^{N - 1} g[k] h\big[(n - k)_{N}\big]
  @end

  To perform circular convolution graphically, $N$ samples $g[n]$ are equally spaced
  around the outer circle in the clockwise direction, and $N$ samples of $h[n]$ are
  displayed on the inner circle in the counterclockwise direction starting at the
  same point. Corresponding samples on the two circles are multiplied, and the products
  are summed to form an output. The successive value of the circular convolution is
  obtained by rotating the inner circle of the one sample in the clockwise direction,
  and repeating the operation of computing the sum of corresponding products. This
  process is repeated until the first sample of inner circle lines up with the first
  sample of the exterior circle again.

** Python Implementation

   %dft_python/circConvWithoutPadding.py%
   #tangle circConvWithoutPadding.py
   @code python
   import numpy as np

   def circonv(g, h):

       if g.size != h.size:
           raise Exception("Sequences not of same length")

       N = g.size
       htr = np.concatenate([[h[0]], h[:0:-1]])

       y = np.zeros(N)

       for n in np.arange(N):
           y[n] = np.sum(g * htr)
           htr = np.roll(htr, 1)

       return y

   @end

* Above with Unequally Sized Functions

  The above implementation raises an exception when the sequences are not of the same
  length. Modify the function such that if the two sequences are not of the same length,
  the shorter sequence is padded with zeros and circular convolution is computed.

** Python Implementation

   %dft_python/circConvWithPadding.py%
   #tangle circConvWithPadding.py
   @code python
   import matplotlib.pyplot as plt
   import numpy as np

   def circonv(g, h):

       if g.size > h.size:
           h = np.concatenate([h, np.zeros(g.size - h.size)])
       elif g.size < h.size:
           g = np.concatenate([g, np.zeros(h.size - g.size)])

       N = g.size
       htr = np.concatenate([[h[0]], h[:0:-1]])

       y = np.zeros(N)

       for n in np.arange(N):
           y[n] = np.sum(g * htr)
           htr = np.roll(htr, 1)

       return y, g, h

   @end

* More Circular Convolution

  Using your function, compute the circular convolution of two sequences
  $g[n] = \\{1, 2, 3, 4, 5\\}$ and $h[n] = \\{2, 2, 0, 1, 1\\}$ and

** Python Implementation

   %dft_python/moreCircConvComp.py%
   #tangle moreCircConvComp.py
   @code python
   import matplotlib.pyplot as plt
   import numpy as np

   def circonv(g, h):

       if g.size > h.size:
           h = np.concatenate([h, np.zeros(g.size - h.size)])
       elif g.size < h.size:
           g = np.concatenate([g, np.zeros(h.size - g.size)])

       N = g.size
       htr = np.concatenate([[h[0]], h[:0:-1]])

       y = np.zeros(N)

       for n in np.arange(N):
           y[n] = np.sum(g * htr)
           htr = np.roll(htr, 1)

       return y, g, h

   g = np.array([1, 2, 3, 4, 5])
   h = np.array([2, 2, 0, 1, 1])

   y, g, h = circonv(g, h)

   plt.figure(figsize = (10, 13))

   plt.subplot(3, 1, 1)
   plt.stem(g, label = "g[n]")
   plt.xlabel("n")
   plt.ylabel("g[n]")
   plt.legend()

   plt.subplot(3, 1, 2)
   plt.stem(h, label = "h[n]")
   plt.xlabel("n")
   plt.ylabel("h[n]")
   plt.legend()

   plt.subplot(3, 1, 3)
   plt.stem(y, label = "$g[n] \circledcirc h[n]$")
   plt.xlabel("n")
   plt.ylabel("$y[n] = g[n] \circledcirc h[n]$")
   plt.legend()


   print("g[n] = ", end = "")
   print(g)

   print("h[n] = ", end = "")
   print(h)

   print("y[n] = ", end = "")
   print(y)

   plt.savefig("../dft_plots/moreCircConvComp.pdf")
   @end

*** Output

    @code
    g[n] = [1 2 3 4 5]
    h[n] = [2 2 0 1 1]
    y[n] = [17. 13. 19. 20. 21.]
    @end

    ---

*** Plots

    {dft_plots/moreCircConvComp.pdf}[More Functions and Their Convolution]


* Verifying Circular Convolution with Property

  If $y[n]$ is the $N$ point circular convolution of the sequences $g[n]$ and
  $h[n]$ defined as $y[n] = g[n] \\circledcirc h[n]$, then $Y[k] = G[k] \\cdot H[k]$,
  where $Y[k]$, $G[k]$, $H[k]$ are the $N$ point DFTs of $y[n]$, $g[n]$ and $h[n]$.
  We can use this property to compute circular convolution as:

  @math
  y[n] = \mbox{IDFT}\big\{ G[k] \cdot H[k] \big\}
  @end

  Use this property to verify your circular convolution result in the previous part.
  Use `fft.fft()` and `fft.ifft()` functions in the `scipy` module to compute the DFTs
  and IDFT.

  %dft_python/circConvWithProperty.py%
  #tangle circConvWithProperty.py
  @code python
  import numpy as np
  from scipy import fft

  def circonv(g, h):

      if g.size > h.size:
          h = np.concatenate([h, np.zeros(g.size - h.size)])
      elif g.size < h.size:
          g = np.concatenate([g, np.zeros(h.size - g.size)])

      N = g.size
      htr = np.concatenate([[h[0]], h[:0:-1]], dtype = np.cdouble)

      y = np.zeros(N, dtype = np.cdouble)

      for n in np.arange(N):
          y[n] = np.sum(g * htr)
          htr = np.roll(htr, 1)

      return y, g, h

  g = np.array([1, 2, 3, 4, 5], dtype = np.cdouble)
  h = np.array([2, 2, 0, 1, 1], dtype = np.cdouble)

  y, g, h = circonv(g, h)

  G = fft.fft(g, axis = 0)
  H = fft.fft(h, axis = 0)

  Y = G * H

  sy = fft.ifft(Y)

  print("Convolution obtained through performing circular convolution:" )
  print(y)

  print("")

  print("Convolution obtained through property:" )
  print(sy)
  @end

** Output

   @code
   Convolution obtained through performing circular convolution:
   [17.+0.j 13.+0.j 19.+0.j 20.+0.j 21.+0.j]

   Convolution obtained through property:
   [17.+0.j 13.+0.j 19.+0.j 20.+0.j 21.+0.j]
   @end

   ---

* Circular Convolution Using Matrix Method

  The $N$ point circular convolution operation can be written in matrix form as

  @math
  \begin{pNiceMatrix}[columns-width=auto]
  y[0]     \\
  y[1]     \\
  y[2]     \\
  \vdots   \\
  y[N - 1] \\
  \end{pNiceMatrix}
  =
  \begin{pNiceMatrix}[columns-width = 1.7cm]
  h[0]     & h[N - 1] &  [N - 2] & \ldots &   h[1] \\
  h[0]     &     h[0] &  [N - 1] & \ldots &   h[2] \\
  h[0]     &     h[1] &     h[0] & \ldots &   h[3] \\
  \vdots   &  \vdots  &   \vdots &  \cdot & \vdots \\
  h[N - 1] & h[N - 2] & h[N - 3] & \ldots &   h[0] \\
  \end{pNiceMatrix}
  \begin{pNiceMatrix}
  g[0]     \\
  g[1]     \\
  g[2]     \\
  \vdots   \\
  g[N - 1] \\
  \end{pNiceMatrix}
  @end

  The elements in each row of the matrix above are obtained by circularly rotating the
  elements of the previous row to the right by $1$ position. Such a matrix is called
  /circulant matrix/. A /circulant matrix/ can be generated using `scipy.linalg.circulant(c)`.
  The argument `c` is the first column of the matrix. Verify the circular convolution
  result using the matrix method.

  %dft_python/circConvWithMatrix.py%
  #tangle circConvWithMatrix.py
  @code python
  import numpy as np
  from scipy.linalg import circulant

  def circonv(g, h):

      if g.size > h.size:
          h = np.concatenate([h, np.zeros(g.size - h.size)])
      elif g.size < h.size:
          g = np.concatenate([g, np.zeros(h.size - g.size)])

      N = g.size
      htr = np.concatenate([[h[0]], h[:0:-1]], dtype = np.cdouble)

      y = np.zeros(N, dtype = np.cdouble)

      for n in np.arange(N):
          y[n] = np.sum(g * htr)
          htr = np.roll(htr, 1)

      return y, g, h

  g = np.array([1, 2, 3, 4, 5], dtype = np.cdouble)
  h = np.array([2, 2, 0, 1, 1], dtype = np.cdouble)

  y, g, h = circonv(g, h)

  circ_mat = circulant(h)

  my = circ_mat @ g

  print("Circulant matrix of h[n]:")
  print(circ_mat)

  print("")

  print("Convolution obtained through performing circular convolution:" )
  print(y)

  print("")

  print("Convolution obtained through matrix method:" )
  print(my)
  @end

** Output

   @code
   Circulant matrix of h[n]:
   [[2.+0.j 1.+0.j 1.+0.j 0.+0.j 2.+0.j]
    [2.+0.j 2.+0.j 1.+0.j 1.+0.j 0.+0.j]
    [0.+0.j 2.+0.j 2.+0.j 1.+0.j 1.+0.j]
    [1.+0.j 0.+0.j 2.+0.j 2.+0.j 1.+0.j]
    [1.+0.j 1.+0.j 0.+0.j 2.+0.j 2.+0.j]]

   Convolution obtained through performing circular convolution:
   [17.+0.j 13.+0.j 19.+0.j 20.+0.j 21.+0.j]

   Convolution obtained through matrix method:
   [17.+0.j 13.+0.j 19.+0.j 20.+0.j 21.+0.j]
   @end

   ---

* Parseval'S Relations

  If $G[k]$ denotes the $N$ point DFT of the length $N$ sequence $g[n]$, then:

  @math
  \sum_{n = 0}^{N - 1} \lvert g[n] \rvert^{2} =
  \dfrac{1}{N} \sum_{k = 0}^{N - 1} \lvert G[k] \rvert^{2}
  @end

  The code below verifies the relation for a sequence $g[n]$:

  %dft_python/parsevalsRelation.py%
  #tangle parsevalsRelation.py
  @code python
  # pass
  @end

* Verifying Parseval'S Relation For a Sequence.

  Generate a randoom complex sequence of $500$ values. Verify Parseval's relation for
  the sequence.

  %dft_python/verifyParsevalsRelation.py%
  #tangle verifyParsevalsRelation.py
  @code python
  # pass
  @end
